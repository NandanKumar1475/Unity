--------------------------------------------------
Physics.Raycast(startPoint, direction, out hitResult, distance, optionalLayer);
--------------------------------------------------

ðŸ§  1. What Is a Raycast (Conceptually)?
--> A Raycast is like shooting an invisible laser beam (a straight line) from a point in a specific direction.
It checks whether this laser hits any collider in the 3D world.

If it hits â†’ you get information about what it hit, where, and how far.

ðŸŽ¯ Real-world analogy:

Imagine you have a laser pointer.
You turn it on â†’ a beam shoots forward. If it hits a wall, you can tell:
Which wall (the collider)
The distance (how far)
The point of contact (hit point)
The surface angle (normal)
Thatâ€™s exactly what Physics.Raycast() does.
------>
Concept â€” What is a Ray in Unity (Mechanically):
-> A Ray is a mathematical line that starts at a specific origin point and extends infinitely in a direction.
In Unity, this is represented by the struct:
public struct Ray
{
    public Vector3 origin;
    public Vector3 direction;
}



ðŸ§© LEVEL 1 â€” The Conceptual Understanding
(What a Raycast really is before writing any code)
--> In Unityâ€™s physics world:
Every visible object can have a Collider (Box, Sphere, Mesh, etc.).
Unity can simulate physics like collisions, gravity, etc.
But sometimes, you donâ€™t want physical collisions â€” you just want to know whatâ€™s in front of something.
Example thought:
â€œIs there an obstacle 5 meters ahead of me?â€
â€œWhich object is under the mouse cursor?â€
â€œWhere should the bullet hit?â€
To answer that â€” Unity gives a feature: Raycasting.

--> LEVEL 2 â€” The Syntax Anatomy (No coding yet, just the formula)
Letâ€™s take the full syntax piece by piece.

Physics.Raycast(origin, direction, out hitInfo, maxDistance, layerMask);
ðŸ§± 1ï¸âƒ£ Physics.Raycast

Physics â†’ Unityâ€™s physics engine class (in UnityEngine).
.Raycast() â†’ a method of that class.
   -->It shoots a ray and checks for hits.

ðŸ§± 2ï¸âƒ£ origin

The starting position of the ray (a Vector3).
Example idea:
From your playerâ€™s head.
From the camera.
From a weapon barrel.

ðŸ§± 3ï¸âƒ£ direction

The direction in which the ray goes.
Itâ€™s also a Vector3.

Example ideas:
transform.forward â†’ forward direction of an object.
Vector3.down â†’ shoot downward.
Vector3.up â†’ shoot upward.

ðŸ§± 4ï¸âƒ£ out hitInfo
This is where the result of the raycast is stored.
It must be written as:
out RaycastHit hit;
 -> The keyword out means â†’
   â€œThis method will fill this variable with data when something is hit.â€
ðŸ§± 5ï¸âƒ£ maxDistance
How far the ray travels (a float).
Example:
100f â†’ check up to 100 Unity units ahead.
If you donâ€™t specify it, Unity will shoot infinitely long (not good for performance).

ðŸ§± 6ï¸âƒ£ layerMask (optional)
A filter: which objects can be hit.
-->LayerMask mask = LayerMask.GetMask("Enemy");
Physics.Raycast(origin, direction, out hit, 100f, mask);

So, the general pattern you must remember is:
Physics.Raycast(startPoint, direction, out hitResult, distance, optionalLayer);


ðŸ§© LEVEL 3 â€” The RaycastHit Result Container
When your ray hits something, Unity gives back an object of type RaycastHit.
| Field        | Type      | Meaning                                 |
| ------------ | --------- | --------------------------------------- |
| `.collider`  | Collider  | The collider that was hit               |
| `.point`     | Vector3   | The world position where it hit         |
| `.normal`    | Vector3   | The perpendicular vector to the surface |
| `.distance`  | float     | How far from origin it hit              |
| `.transform` | Transform | Transform of the hit object             |

Fills a RaycastHit structure with:
hit.point â†’ exact 3D point where ray met collider
hit.normal â†’ surface facing direction (perpendicular vector)
hit.collider â†’ which collider was hit
hit.transform â†’ which GameObject it belongs to
hit.distance â†’ how far from origin the hit happened

--->
| Term           | Mechanically                        | Real Meaning               |
| -------------- | ----------------------------------- | -------------------------- |
| **Ray**        | Infinite line (origin + direction)  | Pure math representation   |
| **Raycast**    | Line checked against colliders      | â€œWhat does this line hit?â€ |
| **RaycastHit** | Collision data                      | â€œWhere, what, and how farâ€ |
| **Used For**   | Interaction, detection, measurement | From shooting to selection |

-----------------------------------------------------------------------------------
1ï¸âƒ£ UI Ray System (EventSystem)

[Mouse Click] or [Touch]
        â†“
  EventSystem.current
        â†“
  â†’ InputModule detects pointer
        â†“
  â†’ GraphicRaycaster fires a "UI Ray"
        â†“
  â†’ Checks Canvas for UI elements
        â†“
  If a UI element is hit â†’ send events:
        OnPointerEnter
        OnPointerDown
        OnClick
        OnPointerExit

-----------------------------------------------------------------
Physics Ray System (3D World)

[Mouse Click]
        â†“
Camera.ScreenPointToRay(Input.mousePosition)
        â†“
Physics.Raycast(ray, out hit, maxDistance)
        â†“
PhysX Engine checks colliders in world
        â†“
If hit â†’ returns RaycastHit (with collider, point, normal)

-------------------------------------------------------------------------------
--> ScreenPointToRay (mouse) â€” Select objects with mouse
-------------------------------------------------------------------------------
